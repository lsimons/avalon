<?xml version="1.0" standalone="no"?>

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.1//EN"
                         "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd">

<chapter>
  <title>Implementing the Dream</title>
  <subtitle>
    We will show how you can use Avalon Framework and Avalon Excalibur to
    realize your services.  We will show just how easy Avalon is to use.
  </subtitle>
  <para>
    After your analysis is complete, you need to create the Components and
    Services that make up your system.  Avalon would be of little use if it
    only described some idioms for you to use.  Even then, the use of those
    idioms and patterns would still help in understanding the overall system.
    Avalon Excalibur provides some useful Components and utilities that you can
    incorporate into your own system that will make your life much easier.  For
    our demonstration, we will go through the process of defining a Component
    that retrieves a document instance from a repository.  If you recall our
    discussion about the theoretical Business Server, we identified this
    Component as a Service.  In practical situations, a Service is a Component
    that has a larger scope.
  </para>
  <section>
    <title>Implementing the Component</title>
    <para>
      At this point, we define how to implement our Component.  We will go
      through the process of implementing the DocumentRepository Component
      previously mentioned.  The first things we need to figure out are the
      concern areas for our Component.  Then we have to figure out how our
      Component will be created and managed.
    </para>
    <section>
      <title>Choosing the Concern Areas</title>
      <para>
        We have already defined the Role and the Interface for our
	DocumentRepository Component in the last chapter, we are ready to
	create the implementation.  Because the interface for the
	DocumentRepository only defines one method, we have an opportunity to
	create a thread-safe Component.  This is the most desired type of
	component because it allows for the least amount of resource
	utilization.  In order for our implementation to be thread-safe, we do
	need to be careful about how we implement the Component.  Since all of
	our documents are stored in a database, and we desire to use an
	external Guardian Component, we will need access to other Components.
	As responsible developers, we will want to log messages that will help
	us debug our component, and track down what is going on internally.
	The beauty of the Avalon Framework is that you only implement the
	interfaces you need, and ignore the ones you don't.  This is where
	Separation of Concerns pays off.  As you find you need a new concern
	area addressed, you merely implement the associated interface, and
	incorporate the new functionality.  To the client of your Component,
	there is no difference.
      </para>
      <para>
        Since it is a design goal to be thread-safe, we already know that we
	need to implement the ThreadSafe interface.  The DocumentRepository
	interface only has one method, so the use of the Component's work
	interface is compatible with that requirement.  Furthermore, we know
	that a Component will not be used before it is fully initialized, nor
	will it be used once it is destroyed.
      </para>
      <para>
        There are a couple of implicit interfaces that we need to implement to
	accomplish the design.  We want our solution to be as secure as
	possible and explicitly track whether the Component is fully
	initialized or not.  To accomplish this goal, we will implement the
	Initializable and Disposable interfaces.  Since specific information
	about our environment may change, or may need to be customized, we need
	to make our DocumentRepository Configurable.  Our Component makes use
	of other Components, and they method that Avalon provides to get
	instances of the required Component is by using a ComponentManager.  We
	will need to implement the Composable interface to get an instance of
	the ComponentManager.
      </para>
      <para>
        Because the DocumentRepository accesses the documents in the database,
	we need to make a decision.  Do we want to take advantage of the Avalon
	Excalibur DataSourceComponent, or do we want to implement our own
	Connection management code.  For the sake of this paper, we will use
	the DataSourceComponent.
      </para>
      <para>
        At this point, our skeleton class looks like this:
      </para>
      <programlisting>
<![CDATA[
public class DatabaseDocumentRepository
extends AbstractLoggable
implements DocumentRepository , Configurable, Composable, Initializable,
           Disposable, Component, ThreadSafe {

    private boolean initialized = false;
    private boolean disposed = false;
    private ComponentManager manager = null;
    private String dbResource = null;

    /**
     * Constructor.  All Components need a public no argument constructor
     * to be a legal Component.
     */
    public DatabaseDocumentRepository() {}

    /**
     * Configuration.  Notice that I check to see if the Component has
     * already been configured?  This is done to enforce the policy of
     * only calling Configure once.
     */
    public final void configure(Configuration conf)
    throws ConfigurationException {
        if (initialized || disposed) {
            throw new IllegalStateException ("Illegal call");
        }

        if (null == this.dbResource) {
            this.dbResource = conf.getChild("dbpool");
            getLogger().debug("Using database pool: " + this.dbResource);
            // Notice the getLogger()?  This is from AbstractLoggable
            // which I extend for just about all my components.
        }
    }

    /**
     * Composition.  Notice that I check to see if the Component has
     * already been initialized or disposed?  This is done to enforce
     * the policy of proper lifecycle management.
     */
    public final void compose(ComponentManager cmanager)
    throws ComponentException {
        if (initialized || disposed) {
            throw new IllegalStateException ("Illegal call");
        }

        if (null == this.manager) {
            this.manager = cmanager;
        }
    }

    public final void initialize() throws Exception {
        if (null == this.manager) throw IllegalStateException("Not Composed");
        if (null == this.dbResource)
            throw IllegalStateException("Not Configured");

        if (disposed) throw IllegalStateException("Already disposed");

        this.initialized = true;
    }

    public final void dispose() {
        this.disposed = true;
    }

    public final Document getDocument(Principal requestor, int refId) {
        if (initialized || disposed) {
            throw new IllegalStateException("Illegal call");
        }

        // TODO: FILL IN LOGIC
    }
}
]]>
      </programlisting>
      <para>
        You will notice some constructs in the above code.  When you are
	designing with security in mind, you should explicitly enforce every
	contract on your Component.  Security is only as strong as the weakest
	link.  You should only use a Component when you are certain it is fully
	initialized, and never use it when it is disposed of.  I placed the
	logic that you would need in this skeleton class because that way you
	can adopt the same practices in classes that you write.
      </para>
    </section>
    <section>
      <title>Instantiating and Managing Components</title>
      <para>
        In order for you to understand how the Container/Component relationship
	works, we will first discuss the manual method of managing Components.
	Next, we will discuss how Avalon's Excalibur Component infrastructure
	hides the complexity from you.  You will still find times when you
	would rather manage components yourself.  Most of the time the power
	and flexibility of Excalibur is just what you need.
      </para>
      <section>
        <title>The Manual Method</title>
	<para>
	  All of Avalon's Components are created somewhere.  The code that
	  creates the Component is that Component's Container.  The Container
	  is responsible for managing the Component's lifecycle from
	  construction through destruction.  A Container can be the static
	  "main" method called from a command line, or it can be another
	  Component.  Remember the Inversion of Control pattern when you
	  design your Containers.  Information and method calls should only
	  flow from the Container to the Component.
	</para>
	<warning>
	  <title>Subversion of Control</title>
	  <para>
	    Subversion of Control is the anti-pattern to Inversion of Control.
	    Subversion of control is done when you pass a reference to a
	    Component's Container to the Component.  It is also done when you
	    have a Component manage it's own lifecycle.  Code that operates in
	    this manner should be considered defective.  The interactions that
	    happen when you confuse the Container/Component relationship make
	    the system harder to debug and security harder to audit.
	  </para>
	</warning>
	<para>
	  In order to manage the child Components, you need to keep a reference
	  to them for their entire lifetime.  Before the Container or any other
	  Component can use the child Component, it must go through the
	  initialization phase of its lifecycle.  For our DocumentRepository,
	  the code will look something like the following:
	</para>
	<programlisting>
<![CDATA[
class ContainerComponent implements Component, Initializable, Disposable {
    DocumentRepository docs = new DatabaseDocumentRepository();
    GuardianComponent guard = new DocumentGuardianComponent();
    DefaultComponentManager manager = new DefaultComponentManager();

    public void initialize() throws Exception {
        this.docs.setLogger(Heirarchy.getLoggerFor("document.repository"));

        DefaultConfiguration pool = new DefaultConfiguration("dbpool");
        pool.setValue("main-pool");
        DefaultConfiguration conf = new DefaultConfiguration("");
        conf.addChild(pool);
        this.docs.configure(conf);

        this.manager.addComponent(DocumentRepository.ROLE, this.docs);
        this.manager.addComponent(GuardianComponent.ROLE, this.guard);
        this.docs.compose(this.manager);
        this.guard.compose(this.manager);

        this.guard.initialize();
        this.docs.initialize();
    }

    public void dispose() {
        this.docs.dispose();
        this.guard.dispose();
    }
}
]]>
	</programlisting>
	<para>
	  For the sake of brevity, I removed all the explicit checking from the
	  above code.  You can see that manually creating and managing
	  Components is very detailed.  If you forget to do one step in the
	  life of a Component, you will see bugs.  This also requires intimate
	  knowledge of the Components you are instantiating.  An alternate
	  approach would be to add a couple methods to the above
	  ContainerComponent that handles the initialization of the components
	  dynamically.
	</para>
      </section>
      <section>
        <title>Automated Autonomy</title>
	<para>
	  Developer's are naturally lazy, so they would spend the time to write
	  a specialized ComponentManager that became the Container for all of
	  their Components in the system.  That way they would not have to be
	  bothered with intimately knowing the interfaces of all the Components
	  in a system.  That can be a daunting task.  The Avalon developers
	  have created just such a beast.  Avalon Excalibur's Component
	  architecture includes a ComponentManager that is controlled by
	  configuration files written in XML.
	</para>
	<para>
	  There is a tradeoff when you relinquish the responsibility of
	  managing a Component to Excalibur's ComponentManager.  You relinquish
	  the fine control over what Components are included in the
	  ComponentManager.  However, if you have a large system, you will find
	  that manual control is a daunting task.  In that case, it is better
	  for the stability of the system for one entity to centrally manage
	  all the Components in a system.
	</para>
	<para>
	  Since there are varying levels of integration you want to achieve
	  with Excalibur's Component Architecture, we will start with the
	  lowest level.  Excalibur has a group of ComponentHolder objects that
	  act as individual Containers for one type of Component.  They manage
	  the complete life of your Component.  Let me introduce the concept of
	  lifestyle interfaces.  A lifestyle interface describes how the system
	  treats a Component.  Since the lifestyle of a component has impact on
	  the running of a system, we need to discuss the implications of the
	  current lifestyle interfaces:
	</para>
	<itemizedlist>
	  <listitem>
	    <para>org.apache.avalon.framework.thread.SingleThreaded</para>
	    <itemizedlist>
	      <listitem>
	        <para>
		  Not thread-safe or reentrant.
		</para>
	      </listitem>
	      <listitem>
	        <para>
		  When no lifestyle interface is supplied, this is assumed.
		</para>
	      </listitem>
	      <listitem>
	        <para>
		  A brand new instance is created every time the Component is
		  requested.
		</para>
	      </listitem>
	      <listitem>
	        <para>
		  Creation and initialization is delayed until you request the
		  Component.
		</para>
	      </listitem>
	    </itemizedlist>
	  </listitem>
	  <listitem>
	    <para>org.apache.avalon.framework.thread.Threadsafe</para>
	    <itemizedlist>
	      <listitem>
	        <para>
		  Component does not maintain state between method calls, and
		  is fully reentrant.
		</para>
	      </listitem>
	      <listitem>
	        <para>
		  One instance is created and shared with all Composables that
		  request it.
		</para>
	      </listitem>
	      <listitem>
	        <para>
		  Creation and initialization is done when ComponentHolder is
		  created.
		</para>
	      </listitem>
	    </itemizedlist>
	  </listitem>
	  <listitem>
	    <para>org.apache.avalon.excalibur.pool.Poolable</para>
	    <itemizedlist>
	      <listitem>
	        <para>
		  Not thread-safe, but is fully reentrant.
		</para>
	      </listitem>
	      <listitem>
	        <para>
		  A pool of instances is created and the free instances are
		  returned to Composables that request it.
		</para>
	      </listitem>
	      <listitem>
	        <para>
		  Creation and initialization is done when ComponentHolder is
		  created.
		</para>
	      </listitem>
	    </itemizedlist>
	  </listitem>
	</itemizedlist>
	<para>
	  The ComponentHolder interface is very simple to deal with.  You
	  initialize the Constructor with the Java class, the Configuration
	  object, the ConfigurationManager, a Context object, and a
	  RoleManager.  If you know that your Component will not need any of
	  the aforementioned items, you can pass a null in its place.  After
	  that, when you need a reference to the Component, you call the "get"
	  method.  After you are done with it, you call the "put" method and
	  pass the Component back to the ComponentHandler.  The following code
	  will make it easier to understand.
	</para>
	<programlisting>
<![CDATA[
class ContainerComponent implements Component, Initializable, Disposable {
    ComponentHolder docs = null;
    ComponentHolder guard = null;
    DefaultComponentManager manager = new DefaultComponentManager();

    public void initialize() throws Exception {
        DefaultConfiguration pool = new DefaultConfiguration("dbpool");
        pool.setValue("main-pool");
        DefaultConfiguration conf = new DefaultConfiguration("");
        conf.addChild(pool);
        this.docs.configure(conf);

        this.docs = ComponentHolder.getComponentHandler(
                                        DatabaseDocumentRepository.class,
                                        conf, this.manager, null, null);
        this.guard = ComponentHolder.getComponentHandler(
                                        DocumentGuardianComponent.class,
                                        null, this.manager, null, null);

        this.docs.setLogger(Heirarchy.getLoggerFor("document.repository"));
        this.guard.setLogger(Heirarcy.getLoggerFor("document.security"));

        this.manager.addComponent(DocumentRepository.ROLE, this.docs);
        this.manager.addComponent(GuardianComponent.ROLE, this.guard);

        this.guard.initialize();
        this.docs.initialize();
    }

    public void dispose() {
        this.docs.dispose();
        this.guard.dispose();
    }
}
]]>
	</programlisting>
	<para>
	  At this point, we only saved ourselves a few lines of code.  We still
	  manually created our Configuration object, we still had to set the
	  Logger, and we still had to initialize and dispose of the
	  ComponentHolder objects.  What we did at this point is simply protect
	  ourselves from changing interfaces.  You may find it better for your
	  code to use this approach.  Excalibur went further though.  Most
	  complex systems have configuration files, and they allow an
	  administrator to alter vital Configuration information.  Excalibur
	  can read a configuration file in the following format, and build the
	  Components in a system from it.
	</para>
	<programlisting>
<![CDATA[
<my-system>
  <component
    role="org.apache.avalon.excalibur.datasource.DataSourceComponentSelector"
    class="org.apache.avalon.excalibur.component.ExcaliburComponentSelector">
     <component-instance hint="documents"
       class="org.apache.avalon.excalibur.datasource.JdbcDataSourceComponent">
         <pool-controller min="5" max="10"/>
         <auto-commit>false</auto-commit>
         <dburl>jdbc:mysql:localhost/mydb</dburl>
         <user>test</user>
         <password>test</password>
      </component-instance>
      <component-instance hint="security">
         <pool-controller min="5" max="10"/>
         <auto-commit>false</auto-commit>
         <dburl>jdbc:mysql:localhost/myotherdb</dburl>
         <user>test</user>
         <password>test</password>
      </component-instance>
  </component>
  <component
    role="org.apache.bizserver.docs.DocumentRepository"
    class="org.apache.bizserver.docs.DatabaseDocumentRepository">
      <dbpool>documents</dbpool>
  </component>
  <component
    role="org.apache.bizserver.docs.GuardianComponent"
    class="org.apache.bizserver.docs.DocumentGuardianComponent">
      <dbpool>security</dbpool>
      <policy file="/home/system/document.policy"/>
  </component>
</my-system>
]]>
	</programlisting>
	<para>
	  The root element can be anything you want.  You will notice that we
	  now have several Components defined.  We have our familiar
	  DocumentRepository class and GuardianComponent class, as well as a
	  couple of Excalibur DataSourceComponent classes.  In addition, now we
	  have some specific configuration information for our Guardian
	  Component.  In order to read that information into your system,
	  Avalon Framework provides some conveniences for you:
	</para>
	<programlisting>
<![CDATA[
DefaultConfigurationBuilder builder = new DefaultConfigurationBuilder();
Configuration systemConf = builder.buildFromFile("/path/to/file.xconf");
]]>
	</programlisting>
	<para>
	  This does simplify all the code we had for hand-building the
	  Configuration element earlier, and it limits the amount of
	  information we need to implicitly know right away.  We will take one
	  last look at our Container class and see if we really have some
	  savings.  Keep in mind that we have five components specified (a
	  ComponentSelector counts as a Component), and configurations for
	  each of them.
	</para>
	<programlisting>
<![CDATA[
class ContainerComponent implements Component, Initializable, Disposable {
    ExcaliburComponentManager manager = new ExcaliburComponentManager();

    public void initialize() throws Exception {
        DefaultConfigurationBuilder builder =
            new DefaultConfigurationBuilder();
        Configuration sysConfig = builder.buildFromFile("./conf/system.xconf");

        this.manager.setLogger(Hierarchy.getLoggerFor("document"));
        this.manager.contextualize(new DefaultContext());
        this.manager.configure(sysConfig);
        this.manager.initialize();
    }

    public void dispose() {
        this.manager.dispose();
    }
}
]]>
	</programlisting>
	<para>
	  Isn't this amazing?  We have more than twice the number Components
	  initialized and ready for use with less than half the code (six lines
	  of code instead of thirteen lines of code).  There is the drawback of
	  the Configuration file looking somewhat crazy, but it minimizes the
	  amount of code you have to write.
	</para>
	<para>
	  There is a lot of activity happening under the hood of the
	  ExcaliburComponentManager.  For each "component" element in the
	  configuration file, Excalibur creates a ComponentHolder for each
	  class entry and maps it to the role entry.  The "component" element
	  and all it's child elements are used for the Configuration of the
	  Component.  When the Component is an ExcaliburComponentSelector, the
	  Excalibur reads each "component-instance" element and performs the
	  same type of operation as before-this time mapping to the hint entry.
	</para>
	<section>
	  <title>Making the Configuration Pretty</title>
	  <para>
	    We can manage the configuration file's appearance with the use of
	    aliases.  Excalibur uses a RoleManager to provide aliases for the
	    configuration system.  A RoleManager can either be a dedicated
	    class that you create, or you can use the DefaultRoleManager and
	    pass in a Configuration object.  If I use the DefaultRoleManager, I
	    will hide the role configuration file inside the jar with the rest
	    of the system.  This is because the role configuration file is only
	    going to be altered by developers.  Below is the interface for the
	    RoleManager:
	  </para>
	  <programlisting>
<![CDATA[
interface RoleManager {
    String getRoleForName( String shorthandName );
    String getDefaultClassNameForRole( String role );
    String getDefaultClassNameForHint( String hint, String shorthand );
}
]]>
	  </programlisting>
	  <para>
	    Let's take a look at how Excalibur uses the RoleManager in our
	    scheme.  First, Excalibur will cycle through all the elements that
	    are direct children of the root element.  This includes all
	    "component" elements like before, but this time when Excalibur
	    doesn't recognize an element name, it asks the RoleManager which
	    role we should use for this Component.  If the RoleManager returns
	    null, the element and all it's child elements are ignored.  Next,
	    Excalibur derives the class name from the role name.  The last
	    method is to dynamically map a class name to a ComponentSelector's
	    child type.
	  </para>
	  <para>
	    Excalibur provides a default implementation of the RoleManager that
	    is configured with an XML configuration file.  The markup is very
	    simple, and it hides all the extra information you don't want your
	    administrator to see.
	  </para>
	  <programlisting>
<![CDATA[
<role-list>
  <role
    name="org.apache.avalon.excalibur.datasource.DataSourceComponentSelector"
    shorthand="datasources" default-class=
    "org.apache.avalon.excalibur.component.DefaultComponentSelector">
     <hint shorthand="jdbc"
       class="org.apache.avalon.excalibur.datasource.JdbcDataSourceComponent"/>
     <hint shorthand="j2ee"
       class="org.apache.avalon.excalibur.datasource.J2eeDataSourceComponent"/>
  </role>
  <role
    name="org.apache.bizserver.docs.DocumentRepository"
    shorthand="repository" default-class=
    "org.apache.bizserver.docs.DatabaseDocumentRepository"/>
  <role
    name="org.apache.bizserver.docs.GuardianComponent"
    shorthand="guardian" default-class=
    "org.apache.bizserver.docs.DocumentGuardianComponent"/>
</role-list>
]]>
	  </programlisting>
	  <para>
	    In order to use the RoleManager, you do need to alter the
	    "initialize" method of our Container class.  You are using the
	    configuration builder to build a Configuration tree from this
	    file.  Please remember, if you are going to use a RoleManager, you
	    must call the "setRoleManager" method <emphasis>before</emphasis>
	    the "configure" method.  To demonstrate how you would retrieve this
	    XML file from the class loader, I will demonstrate the technique
	    below:
	  </para>
	  <programlisting>
<![CDATA[
DefaultConfigurationBuilder builder =
            new DefaultConfigurationBuilder();
Configuration sysConfig = builder.buildFromFile("./conf/system.xconf");
Configuration roleConfig = builder.build(
            this.getClass().getClassLoader()
            .getResourceAsStream("/org/apache/bizserver/docs/document.roles"));

RoleManager roles = new DefaultRoleManager();
roles.setLogger(Hierarchy.getLoggerFor("document.roles"));
roles.configure(roleConfig);

this.manager.setLogger(Hierarchy.getLoggerFor("document"));
this.manager.contextualize(new DefaultContext());
this.manager.setRoleManager(roles);
this.manager.configure(sysConfig);
this.manager.initialize();
]]>
	  </programlisting>
	  <para>
	    Since we added six more lines of code, we need to see what it
	    bought us.  Our final configuration file can be written like this:
	  </para>
	  <programlisting>
<![CDATA[
<my-system>
  <datasources>
     <jdbc hint="documents">
         <pool-controller min="5" max="10"/>
         <auto-commit>false</auto-commit>
         <dburl>jdbc:mysql:localhost/mydb</dburl>
         <user>test</user>
         <password>test</password>
      </jdbc>
      <jdbc hint="security">
         <pool-controller min="5" max="10"/>
         <auto-commit>false</auto-commit>
         <dburl>jdbc:mysql:localhost/myotherdb</dburl>
         <user>test</user>
         <password>test</password>
      </jdbc>
  </datasources>
  <repository>
      <dbpool>documents</dbpool>
  </repository>
  <guardian>
      <dbpool>security</dbpool>
      <policy file="/home/system/document.policy"/>
  </guardian>
</my-system>
]]>
	  </programlisting>
	  <para>
	    As you can see, this is much more readable than how we started.
	    Now we can add any number of components to our system, and we won't
	    have to write any more code to support them.
	  </para>
	</section>
      </section>
    </section>
  </section>
  <section>
    <title>Using the Component</title>

<!-- PLACEHOLDER -->

  </section>
  <section>
    <title>Excalibur's Utitities</title>
    <para>
      This last section is included to give you an idea of the types of
      Components and utilities that are included with Apache Avalon Excalibur.
      These utilities are robust, and fully usable in production systems.  We
      do have an unofficial staging project called "Scratchpad" where we iron
      out implementation details for potential new utilities.  Scratchpad
      utilities are of varying quality, and their use is not
      guaranteed&mdash;although you may have good experience with them.
    </para>
    <section>
      <title>Command Line Interface (CLI)</title>
      <para>
        The CLI utilities are used by a number of projects including Avalon
	Phoenix and Apache Cocoon to process command line arguments.  It
	provides facilities to print help responses, and to process options by
	either a short name or a long name.
      </para>
    </section>
    <section>
      <title>Collection Utilities</title>
      <para>
        The collection utilities provide some enhancements to the 
	<trademark>Java</trademark> Collections API.  Among them is the ability
	to find the intersections between two lists and a
	<classname>PriorityQueue</classname> that is an enhancement to
	<classname>Stack</classname> to allow the priority of objects override
	the simple first in/last out <classname>Stack</classname>
	implementation.
      </para>
    </section>
    <section>
      <title>Component Management</title>
      <para>
        We already discussed the use of this in the previous section.  This is
	Excalibur's most complex beast, but it provides a lot of functionality
	in just a few classes.  It will make one distinction more than simple
	<classname>SingleThreaded</classname> or
	<classname>ThreadSafe</classname> for managing a component type:
	<classname>Poolable</classname>.  If a Component implements Excalibur's
	<classname>Poolable</classname> interface instead of the
	<classname>SingleThreaded</classname> interface, it will maintain a
	pool of Components and reuse instances.  Most of the time this works
	great.  For those last remaining times where a Component cannot be
	reused, use the <classname>SingleThreaded</classname> interface.
      </para>
    </section>
    <section>
      <title>Thread Utilities</title>
      <para>
        The <emphasis>concurrent</emphasis> package contains several classes
	to assist in multithreaded programming: <classname>Lock</classname>
	(a mutex implementation), <classname>DjikstraSemaphore</classname>,
	<classname>ConditionalEvent</classname>, and
	<classname>ThreadBarrier</classname>.
      </para>
    </section>
    <section>
      <title>Datasources</title>
      <para>
        This is modeled after the <classname>javax.sql.DataSource</classname>
	class, but simplified.  There are two implementations of the
	<classname>DataSourceComponent</classname>: one that pools JDBC
	connections explicitly, and one that uses a J2EE application server's
	<classname>javax.sql.DataSource</classname> class.
      </para>
    </section>
    <section>
      <title>Input/Output (IO) Utilities</title>
      <para>
        The IO utilties provide a number of <classname>FileFilter</classname>s
	and other <classname>File</classname> and IO specific utilities.
      </para>
    </section>
    <section>
      <title>Pool Implementations</title>
      <para>
        The Pool implementations provide a <classname>Pool</classname> for
	every occasion.  You have an implementation that is blazingly fast, but
	only usable in one thread&mdash;which should be ok for implementing a
	FlyWeight pattern.  You also have <classname>DefaultPool</classname>,
	which does not manage the number of objects in its pool.
	<classname>SoftResourceManagingPool</classname> decommissions objects
	that exceed a threshold when they are returned.  Lastly,
	<classname>HardResourceManagingPool</classname> throws an exception
	when you have reached the maximum number of objects.  The last three
	pools are all <classname>ThreadSafe</classname>.
      </para>
    </section>
    <section>
      <title>Property Utilities</title>
      <para>
        The property utilities are used in conjunction with Context objects.
	They give you the ability to expand "variables" in your
	<classname>Resolvable</classname> object.  It works like this:
	<parameter>"${resource}"</parameter> will look for a Context value
	named <parameter>"resource"</parameter> and substitute its value
	for the symbol.
      </para>
    </section>
  </section>
</chapter>
