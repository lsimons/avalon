<?xml version="1.0"?>

<!DOCTYPE document SYSTEM "dtd/document-v10.dtd">

<document>
  <header>
    <title>Avalon Design Documentation</title>
    <subtitle>What is a component?</subtitle>
    <version>1.0</version>
    <authors>
      <person id="LS" name="Leo Simons" email="mail@leosimons.com"/>
    </authors>
  </header>
  <body>
    <s1 title="Introduction to COP"> 
      <p>
        Component Oriented Programming, or COP for short, takes Object Oriented
        Programming one step further. Regular OOP organizes data object into
        entities that take care of themselves. There are many advantages to this
        approach. I'll assume that you, being a java programmer, are familiar
        with those.
      </p>
      <p>
        It also has a big limitation: that of object co-dependency. To remove that
        limitation, a more rigid idea had to be formalized: the Component. The key
        difference between a regular object and a component is that a component is
        completely replaceable.
      </p>
      <p>
        There is a lot of buzz in the industry touting Component Based Design
	(CBD).  You will find, that the definition of a Component in Avalon
	is more formal than most companies' definition of a Component.  Any
	system developed with the principles of Avalon can claim CBD.  In
	fact the Avalon Framework formalizes CBD more rigidly than the marketing
	definition.  Do not be fooled though, CBD and COP aren't necessarily
	the same thing.  Component Based Design refers to how a system is
	designed and not how it is implemented.  Component Oriented Programming,
	on the other hand, refers to how a system is implemented and not how
	it is designed.  In practice, you can't implement COP without first
	designing with Components in mind.
      </p>
    </s1>
    <s1 title="Components in Avalon">
      <p>
        At the core of the Avalon framework is the Component. We define it as "a
        passive entity that performs a specific role". This is important to grasp
        because it requires a specific way of thinking.
      </p>
      <s2 title="A passive API">
        <p>
          A passive entity must employ a passive API. A passive API is one that is
          acted upon, versus one that acts itself. See the
          <link href="inversion-of-control.html">Inversion of Control</link> pattern
          for an explanation.
        </p>
      </s2>
      <s2 title="A specific Role">
        <p>
          The concept of roles come from the theater.  A play, musical,
          or movie will have a certain number of roles that actors play.
          Although there never seems to be a shortage of actors, there
          are a finite number of roles.  I am not going to make reference
          to different types of roles at this point, but simply bring
          the concept to light.  The function or action of a role is
          defined by it's script.
        </p>
        <p>
          We are introducing this concept now because you need to have it
          in mind when you are designing your system architecture.  Think
          of the different roles in your system, and you will have your
          "cast" of components so to speak.
        </p>
        <p>
          For each role, you need to specify it's script, or interface to
          the rest of the system.  To be honest the interface is not enough.
          There are specific contracts that you must define and keep in mind
          when you specify your interfaces.  In other words, what users
          of the Component must provide, and what the Component produces.
          When the interface and contract are defined, you can work on your
          implementation.
        </p>
      </s2>
    </s1>
    <s1 title="Writing the Component">
      <p>
        John Milton wrote, "No man is an island." to communicate that we
        are all interdependent.  The same is true for the Component.  That
        is why there are different concerns regarding the Component.  In
        the section on roles we specified one of the concerns: the role.
        The concerns directly supported by Avalon are: configuration,
        external component use, management, and execution.
      </p>
      <p>
        As you might of guessed, each one of these concerns has a separate
        interface that describes that concern.  We will delve deeper into
        the interfaces and the reasoning behind them in other sections.  It
        is important to know the order of precedence for the concerns so
        that you know the overall contracts of how they are put together.
      </p>
      <ol>
        <li>
          <strong>Configurable:</strong> marks an object that can be configured.
        </li>
        <li>
          <strong>Composable:</strong> marks an object that uses Components.
        </li>
        <li>
          <strong>Initializable:</strong> marks an object that can be initialized.
        </li>
        <li>
          <strong>Disposable:</strong> marks an object that can be disposed.
        </li>
        <li>
          <strong>Stoppable:</strong> marks an object that can be started and stopped.
        </li>
      </ol>
      <p>
        The contract surrounding this order means that the methods defined
        by each of those interfaces are called in a specific order by the object
        that created the Component.  Each interface represents a narrow view
        of the Component or object being controlled.
      </p>
      <note>
        Notice that each interface is separate from Component, so you can use
        them for simple objects.
      </note>
      <s2 title="How is the Component Going to be Used?">
        <p>
          The first step in writing the Component is determining how it is going
          to be used.  There will be a number of times where you have a powerful
          Component that can be used in many different contexts.  Those contexts
          may include executing the Component from the command line (separate
          from Avalon), using it as a part of a sub system, or using it as an
          integral part of Avalon.
        </p>
        <s3 title="Part of Avalon">
          <p>
            All Components are an integral part of Avalon, so there is really
            nothing to be done beyond specifying its interface (role).  It is
            important to identify and document it's social contract with the
            rest of the system.  What I mean by social contract is the order
            of dependencies, what it needs to function, and what it supplies
            to the rest of the system.
          </p>
        </s3>
        <s3 title="Part of a Sub System">
          <p>
            A sub system can either be part of Avalon, or live in a separate
            context.  A perfect example would be a Component that can function
            within a Servlet or Enterprise Application.  Neither of those
            contexts are native to Avalon (though they can easily be built
            on top of Avalon).
          </p>
          <p>
            It is important to do even more careful planning than in the
            first scenario.  The reason is that you want the interface to be
            as generic as possible and still accurately represent its role.
          </p>
          <p>
            Because the contexts that may not be an integral part of Avalon,
            you must take care to use the Component in the same manner as
            Avalon would.  That means that you follow the order of concerns
            that Avalon has specified for those concerns.
          </p>
        </s3>
        <s3 title="A Stand Alone Program">
          <p>
            When you are designing a Component to be run from the command
            line (or directly by the operating system), try to separate
            the main function from the Component itself.  This is imperative
            in order to maintain the passive API of Avalon.  By designing
            your Component in the manner stated in the previous section,
            you have effectively minimized what the main function has to
            do.
          </p>
          <p>
            Follow the practice of having an object dedicated to the main
            function that includes the parsing of the command line parameters
            and initialization of the Component.  When the Component is used
            the exact same way in every context (including the command line),
            you minimize the number of locations to look while debugging.
          </p>
          <note>
            A common mistake is to combine the main function in the
            implementation of the Component.  This requires violating the
            contracts and principles that Avalon is built upon.  This
            violation of the pattern of "Inversion of Control" is
            aptly dubbed "Subversion of Control" (thanks to Steven Coffman
            for the name of the anti-pattern).
          </note>
        </s3>
      </s2>
    </s1>
  </body>
  <footer>
    <legal>
      Copyright (c) @year@ The Jakarta Apache Project All rights reserved.
      $Revision: 1.3 $ $Date: 2001/07/05 14:52:04 $
    </legal>
  </footer>
</document>

