<?xml version="1.0"?>

<!DOCTYPE document SYSTEM "dtd/document-v10.dtd">

<document>
  <header>
    <title>Avalon Developer Documentation</title>
    <subtitle>Designing for Reuse</subtitle>
    <authors>
      <person name="Berin Loritsch" email="bloritsch@apache.org"/>
    </authors>
  </header>
  <body>
    <s1 title="Rules for Reuse">
      <p>
        If you are asking yourself why this section is even included,
        the answer is that a well designed framework is designed to
        be modular and black-box in nature.  If you are new to Object
        Oriented Programming (OOP), then I suggest you read
        <link href="http://www.laputan.org/drc/drc.html">
          &quot;Designing Reusable Classes&quot;
        </link> by Ralph E. Johnson and Brian Foote.  It provides a
        good primer on OOP techniques.
      </p>
      <p>
        Within this chapter, I will summarize the 12 rules for designing
        for code reuse (what frameworks promote).
      </p>
      <s2 title="Recursion Introduction">
        <p>
          Use the same interface for communication with components of
          the same type.  It allows the swapping of those components
          for other components of the same type without breaking existing
          code.
        </p>
        <p>
          If you need additional functionality, either create proxy
          objects that implement the interface, or add it by subclassing
          (hence the name &quot;Recursion Introduction&quot;.  Even if
          there is no recursion happening, it appears to opperate in the
          same manner.
        </p>
      </s2>
      <s2 title="Eliminate Case Analysis">
        <p>
          Avoid testing to see if an object is an instance of a particular
          class.  Usually, if you think you need that approach then a
          redesign will help emmensely.
        </p>
      </s2>
      <s2 title="Reduce the Number of Arguments">
        <p>
          Methods with a half-dozen arguments are hard to read, and can
          usually be accomplished with an object that represents that
          set of arguments.  It also makes it easier to track down the
          problems.
        </p>
      </s2>
      <s2 title="Reduce the Size of Methods">
        <p>
          Most of your methods should only need to be a few lines long.
          Methods that are very long (like 50 lines or so) are too complex,
          and should be considered guilty of bad design until proven
          innocent.
        </p>
      </s2>
      <s2 title="Class Heirarchies Should be Deep and Narrow">
        <p>
          Basically, this rule is saying it is better to start with an
          Abstract object, and specialize off of that than it is to
          reimplement the interface for each object.  For example, in
          a GUI you will have an HTMLTextBox that extends PlainTextBox
          that extends AbstractTextBox that extends AbstractControl.
          You do that instead of an HTMLTextBox that implements the
          Control interface. (You get the point).
        </p>
      </s2>
      <s2 title="The Top of the Class Heirarchy Should be Abstract">
        <p>
          Always provide an abstract base class to extend for your
          specializations.  The majority of the functionality and
          behavior is well defined in those cases--making it easier
          to deciphor what the intents of the interface designer were.
        </p>
      </s2>
      <s2 title="Minimize Accesses to Variables">
        <p>
          This point formalizes the principles of data hiding.  Try not
          to expose class attributes to other classes, but protect them
          by methods.  If an attribute changes name, then you only have
          one place to update the code instead of hundreds.
        </p>
      </s2>
      <s2 title="Subclasses Should be Specializations">
        <p>
          Think a subclass &quot;is a&quot; [superclass].  If what you
          are trying to do is make a Component into a ComponentManager,
          then you are violating the spirit of the framework.  A better
          approach is to use containment in that case (i.e. a class
          &quot;has a&quot; external class).
        </p>
      </s2>
      <s2 title="Split Large Classes">
        <p>
          If a class has 50+ methods, then it is most likely trying to
          do too much.  Look at separating the functionality into
          separate components.  Like methods that are too long, classes
          that violate this rule should be considered guilty of wrong
          design until proven innocent.
        </p>
      </s2>
      <s2 title="Factor Implementation Differences Into Subcomponents">
        <p>
          If a subclass implements a method completely different from
          the superclass, then it is not really a specialization.  It
          should be split off from that class heirarchy tree.
        </p>
      </s2>
      <s2 title="Separate Methods that Do Not Communicate">
        <p>
          Sometimes in building a framework you run into a case where
          you have different views of the same data.  In these cases,
          you can have some attributes that describe how to generate
          the data, and some attributes that describe the data itself.
          It is better to separate these two views into separate classes.
          The semantics are different enough to justify this solution.
        </p>
      </s2>
      <s2 title="Send Messages to Components instead of to This">
        <p>
          The point of this point is that you want to build your framework
          based on Components, and not inheritance.  Avalon takes this
          point to heart.  In order to illustrate, I will give two examples
          of the same thing.  The scenario is that we have a data structure
          that we want to output to an arbitrary format.
        </p>
        <p>
          In the following example, we will use the java <code>this</code>
          object and an inheritance based framework.  As you can see, this
          would be a bear to maintain, and it won't easily be extended.
        </p>
        <source>
abstract class AbstractExampleDocument {
    // skip some code ...
    public void output(Example structure) {
        if (structure != null) {
            this.format(Example structure);
        }
    }

    protected void format(Example structure);
}
        </source>
        <p>
          In the next example, we will use the Avalon Component based
          architecture.  There is a clean separation between the purpose
          of the objects, and you can exchange and extend formatting
          without worrying about any other concerns.
        </p>
        <source>
class DefaultExampleDocument {
    // skip some code ...
    public void output(Example structure) {
       ExampleFormatter output = (ExampleFormatter) manager.lookup(Roles.FORMATTER);
       if (structure != null) {
            output.format(structure);
       }
    }
}
        </source>
        <p>
          An inheritance based framework (White Box) can be converted
          into a component based framework (Black Box) structure by
          replacing overridden methods by method calls (message sends)
          to components.  Component based architecture is much more
          flexible in this regard.
        </p>
      </s2>
      <s2 title="Eliminate Implicit Parameter Passing">
        <p>
          Just because two methods share the same information within the
          class does not mean that it should be done in that manner.
          Many times, that attribute that is shared should be passed
          as a parameter of the method instead of directly accessing
          the attribute.
        </p>
      </s2>
    </s1>
  </body>
  <footer>
    <legal>
      Copyright (c) @year@ The Jakarta Apache Project All rights reserved.
      $Revision: 1.2 $ $Date: 2001/03/02 01:53:52 $
    </legal>
  </footer>
</document>
